#include <sys/time.h>

#include <exception>
#include <iostream>
#include <memory>
#include <boost/scoped_ptr.hpp>
#include <boost/ref.hpp>
#include <boost/thread.hpp>

#include <disruptor/disruptor.h>

#include <gtest/gtest.h>

#include <TestUtils.h>

using namespace disruptor;

static const uint64_t ONE_SEC_IN_NANO = 1000UL * 1000UL * 1000UL;
static const uint64_t BENCHMARK_NS = 1000UL * 50UL;

class Producer
{
    private:
        long iterations_;
        Disruptor<test::TimestampEvent>& disruptor_;

    public:
        explicit Producer(long i, Disruptor<test::TimestampEvent>& disruptor) :
            iterations_(i),
            disruptor_(disruptor)
        {
        }

        void operator() ()
        {
            boost::scoped_ptr<test::TimestampEventTranslator> translator(new test::TimestampEventTranslator);
            for (long i=0; i<iterations_; i++) {
                disruptor_.publishEvent(translator.get());
                /*
                if(i % 1000 == 0)
                    boost::this_thread::yield();
                    */
                /*
                struct timespec tm;
                tm.tv_sec = 0;
                tm.tv_nsec = 1000;
                clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &tm, NULL);
                */
            }
        }
};

template<int NumProducer>
class SingleYielding : public Disruptor<test::TimestampEvent>
{
    public:
        SingleYielding(int buffer_size, test::TimestampBatchHandler* handler) :
            Disruptor<test::TimestampEvent>(buffer_size, kSingleThreadedStrategy, kYieldingStrategy, handler, NULL)
        {
        }

        int supportedProducerNum() const
        {
            return NumProducer;
        }
};

template<int NumProducer>
class MultiYielding : public Disruptor<test::TimestampEvent>
{
    public:
        MultiYielding(int buffer_size, test::TimestampBatchHandler* handler) :
            Disruptor<test::TimestampEvent>(buffer_size, kMultiThreadedStrategy, kYieldingStrategy, handler, NULL)
        {
        }

        int supportedProducerNum() const
        {
            return NumProducer;
        }
};

template<int NumProducer>
class MultiLowContentionYielding : public Disruptor<test::TimestampEvent>
{
    public:
        MultiLowContentionYielding(int buffer_size, test::TimestampBatchHandler* handler) :
            Disruptor<test::TimestampEvent>(buffer_size, kMultiThreadedLowContentionStrategy, kYieldingStrategy, handler, NULL)
        {
        }

        int supportedProducerNum() const
        {
            return NumProducer;
        }
};

template<int NumProducer>
class SingleBusySpin : public Disruptor<test::TimestampEvent>
{
    public:
        SingleBusySpin(int buffer_size, test::TimestampBatchHandler* handler) :
            Disruptor<test::TimestampEvent>(buffer_size, kSingleThreadedStrategy, kBusySpinStrategy, handler, NULL)
        {
        }

        int supportedProducerNum() const
        {
            return NumProducer;
        }
};

template<int NumProducer>
class MultiBusySpin : public Disruptor<test::TimestampEvent>
{
    public:
        MultiBusySpin(int buffer_size, test::TimestampBatchHandler* handler) :
            Disruptor<test::TimestampEvent>(buffer_size, kMultiThreadedStrategy, kBusySpinStrategy, handler, NULL)
        {
        }

        int supportedProducerNum() const
        {
            return NumProducer;
        }
};

template<int NumProducer>
class MultiLowContentionBusySpin : public Disruptor<test::TimestampEvent>
{
    public:
        MultiLowContentionBusySpin(int buffer_size, test::TimestampBatchHandler* handler) :
            Disruptor<test::TimestampEvent>(buffer_size, kMultiThreadedLowContentionStrategy, kBusySpinStrategy, handler, NULL)
        {
        }

        int supportedProducerNum() const
        {
            return NumProducer;
        }
};


template <typename DisruptorType>
class DisruptorPerfFixture : public ::testing::Test
{
    protected:
        test::TimestampBatchHandler      tm_handler_;
        DisruptorType                    disruptor_;

        virtual ~DisruptorPerfFixture() 
        {
        }

        DisruptorPerfFixture()
            : tm_handler_(BENCHMARK_NS)
            , disruptor_(1024 * 8, &tm_handler_)
        {
        }

        virtual void SetUp()
        {
        }

        virtual void TearDown()
        {
        }

};

// Define typed tests
typedef ::testing::Types< 
        SingleYielding<1>, 
        MultiYielding<1>,
        MultiYielding<3>,
        MultiLowContentionYielding<3>,
        SingleBusySpin<1>,
        MultiBusySpin<1>,
        MultiBusySpin<3>,
        MultiLowContentionBusySpin<3> > DisruptorTypes;
TYPED_TEST_CASE(DisruptorPerfFixture, DisruptorTypes);

TYPED_TEST(DisruptorPerfFixture, PushThroughTimeEventWithSingleComsumer)
{
    long iterations = 1000L * 10;
    // Note: we are inside a derived class template, use this-> to access fixture memebers
    const int num_producers = this->disruptor_.supportedProducerNum();
    std::vector<Producer> producerObjs(num_producers, Producer(iterations, (this->disruptor_)));
    boost::thread_group producers;

    struct timespec start_time, end_time;
    // +----- start timer -----+
    clock_gettime(CLOCK_MONOTONIC, &start_time);

    for (int i = 0; i < num_producers; ++i ) {
        producers.create_thread( boost::ref<Producer>( producerObjs[i] ) );
    }

    iterations = num_producers * iterations;
    int64_t expected_sequence = iterations - 1;
    while (this->disruptor_.processor().getSequence()->get() < expected_sequence) {}

    clock_gettime(CLOCK_MONOTONIC, &end_time);
    // +----- stop timer -----+

    double start, end;
    start = start_time.tv_sec + ((double) start_time.tv_nsec / (ONE_SEC_IN_NANO));
    end = end_time.tv_sec + ((double) end_time.tv_nsec / (ONE_SEC_IN_NANO));
    double duration = end - start;

    std::cout.precision(15);
    std::cout << num_producers << "-Publisher-1-Processor performance: ";
    std::cout << (iterations * 1.0) / duration << " ops/secs" << std::endl;
    std::cout << "iterations = " << this->tm_handler_.count() << std::endl;
    std::cout << "duration = " << duration << " secs" << std::endl;
    std::cout << "ns per op = " << duration * ONE_SEC_IN_NANO /iterations << std::endl;
    double mean = (this->tm_handler_.total_latency() / iterations);
    std::cout << "mean latency = " << mean << " ns" << std::endl;
    std::cout << "max latency = " << this->tm_handler_.max_latency() << " ns" << std::endl;
    std::cout << "min latency = " << this->tm_handler_.min_latency() << " ns" << std::endl;
    std::cout << "\% latency below " << BENCHMARK_NS << " ns = " << this->tm_handler_.latency_below_benchmark()/1.0/iterations*100 << "\%" << std::endl;

    //RecordProperty("mean_latency", (this->tm_handler_.total_latency() / iterations) );

    this->disruptor_.stop();
    producers.join_all();
}
