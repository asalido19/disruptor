// Copyright (c) 2011, François Saint-Jacques
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the disruptor-- nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL FRANÇOIS SAINT-JACQUES BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Changes Copyright (c) 2012 - 2013, IG Index Ltd.

#ifndef DISRUPTOR2_SEQUENCE_BARRIER_H_
#define DISRUPTOR2_SEQUENCE_BARRIER_H_

#include <vector>
#include <boost/atomic.hpp>

#include <disruptor/exceptions.h>
#include <disruptor/interface.h>

namespace disruptor {

class ProcessingSequenceBarrier : public ISequenceBarrier
{
    public:
        ProcessingSequenceBarrier(IWaitStrategy* wait_strategy,
                Sequence* sequence,
                const DependentSequences& dependent_sequences)
            : wait_strategy_(wait_strategy)
            , cursor_sequence_(sequence)
            , dependent_sequences_(dependent_sequences)
            , alerted_(false)
        {
        }

        ProcessingSequenceBarrier(IWaitStrategy* wait_strategy,
                Sequence* sequence)
            : wait_strategy_(wait_strategy)
            , cursor_sequence_(sequence)
            , alerted_(false)
        {
        }

        virtual int64_t waitFor(const int64_t& sequence)
        {
            return wait_strategy_->waitFor(sequence,
                    *cursor_sequence_, dependent_sequences_, *this);
        }

        virtual int64_t waitFor(const int64_t& sequence,
                                const boost::posix_time::time_duration& timeout)
        {
            return wait_strategy_->waitFor(sequence,
                    *cursor_sequence_, dependent_sequences_, *this, timeout);
        }

        virtual int64_t getCursor() const
        {
            return cursor_sequence_->get();
        }

        virtual bool isAlerted() const
        {
            return alerted_.load(boost::memory_order_acquire);
        }

        virtual void alert()
        {
            alerted_.store(true, boost::memory_order_release);
        }

        virtual void clearAlert()
        {
            alerted_.store(false, boost::memory_order_release);
        }

        virtual void checkAlert() const
        {
            if (isAlerted()) {
                throw AlertException();
            }
        }

    private:
        IWaitStrategy* wait_strategy_;
        Sequence* cursor_sequence_;
        DependentSequences dependent_sequences_;
        boost::atomic<bool> alerted_;
};

};  // namespace disruptor

#endif
