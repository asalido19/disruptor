// Copyright (c) 2011, François Saint-Jacques
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the disruptor-- nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL FRANÇOIS SAINT-JACQUES BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Changes Copyright (c) 2012 - 2013, IG Index Ltd.

#ifndef DISRUPTOR2_EVENT_PROCESSOR_H_
#define DISRUPTOR2_EVENT_PROCESSOR_H_

#include <exception>

#include <boost/atomic.hpp>
#include <boost/utility.hpp>

#include <disruptor/ring_buffer.h>

namespace disruptor {


template <typename T>
class BatchEventProcessor : public IEventProcessor<T>
                          , public boost::noncopyable
{
public:
    BatchEventProcessor(RingBuffer<T>* ring_buffer,
                        SequenceBarrierPtr sequence_barrier,
                        IEventHandler<T>* event_handler,
                        IExceptionHandler<T>* exception_handler,
                        const boost::posix_time::time_duration& max_idle_time)
        : running_(false)
        , ring_buffer_(ring_buffer)
        , sequence_barrier_(sequence_barrier)
        , event_handler_(event_handler)
        , exception_handler_(exception_handler)
        , wait_(max_idle_time)
    {}

    virtual Sequence* getSequence() { return &sequence_; }
    //virtual PaddedLong* getSequence() { return &sequence_; }

    virtual void halt()
    {
        running_.store(false);
        sequence_barrier_->alert();
    }

    virtual void run()
    {
        bool expected = false;
        if ( !running_.compare_exchange_strong(expected, true) ) {
            throw std::runtime_error("Thread is already running");
        }

        // Note: must keep this line commented, otherwise, if Halt is called
        // before clearAlert, then the alert status will never be caught
        //sequence_barrier_->clearAlert();
        event_handler_->onStart();

        T* event = NULL;
        int64_t next_sequence = sequence_.get() + 1L;

        while (true) {
            try {
                int64_t available_sequence =
                    sequence_barrier_->waitFor(next_sequence, wait_);

                int64_t batch_size = available_sequence - next_sequence + 1;

                while (next_sequence <= available_sequence) {
                    event = ring_buffer_->get(next_sequence);
                    event_handler_->onEvent(next_sequence,
                            batch_size,
                            next_sequence == available_sequence, event);
                    next_sequence++;
                }

                if (wait_.ticks() != 0) {
                    // not matter there was events or not, always notify handler
                    // with NULL event for special handling
                    event_handler_->onEvent(next_sequence,
                            0,
                            next_sequence == available_sequence, NULL);
                }

                sequence_.set(next_sequence - 1L);
            }
            catch(const AlertException& e) {
                break;
            }
            catch(const std::exception& e) {
                if (exception_handler_) {
                    exception_handler_->handle(e, next_sequence, event);
                }
                sequence_.set(next_sequence);
                next_sequence++;
            }
        }

        event_handler_->onShutdown();
        running_.store(false);
    }

    void operator()() { run(); }

private:
    boost::atomic<bool> running_;
    Sequence sequence_;

    RingBuffer<T>* ring_buffer_;
    SequenceBarrierPtr sequence_barrier_; // barrier is (share)owned by processors
    IEventHandler<T>* event_handler_;
    IExceptionHandler<T>* exception_handler_;
    boost::posix_time::time_duration wait_; 
};

};  // namespace disruptor

#endif
